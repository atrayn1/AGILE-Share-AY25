# This will make the visualization of the graph

import networkx as nx
import numpy as np
import plotly.graph_objects as go
from networkx.algorithms.community import girvan_newman
from tests.AY25.testgraph import process_data

# Define an adjacency matrix (Example: 4 people)
# need this matrix to be the adjacency matrix we actually use

# Path to the CSV file
csv_file = "data/hainan.csv"

# Read the CSV file using pandas
data, df = process_data(csv_file)
print(df)
# Create the graph
graph = createGraph(data)

connectNodes(graph, 1, df, 5, 5, 50)
adj_matrix = graph.adjacency_matrix

# Create a NetworkX graph from the adjacency matrix
G = nx.from_numpy_array(adj_matrix)

# Assume these are the people represented by each row of the adjacency matrix
people = [
    "adid_1", "adid_2", "adid_3", "adid_4", "adid_5", "adid_6", "adid_7", "adid_8", 
    "adid_9", "adid_10", "adid_11", "adid_12", "adid_13", "adid_14", "adid_15", "adid_16", 
    "adid_17", "adid_18", "adid_19", "adid_20"
]

'''
trying to center the graph around a specific adid...
'''
def most_central_node(adj_matrix):
    """
    Given an adjacency matrix, this function returns the index of the most central node
    based on betweenness centrality.
    Parameters:
    adj_matrix (numpy.ndarray): Adjacency matrix of the graph
    Returns:
    int: Index of the most central node
    """
    # Create a NetworkX graph from the adjacency matrix
    G = nx.from_numpy_array(adj_matrix)
    # Calculate betweenness centrality for all nodes
    centrality = nx.betweenness_centrality(G)
    # Find the node with the highest betweenness centrality
    most_central_node = max(centrality, key=centrality.get)
    return most_central_node

'''
You can either center on the most central node in the matrix, or 
you can also center it around a certain node of your choosing
'''
center_node = most_central_node(adj_matrix)
#center_node = 9
# Get initial layout positions (using spring_layout)
pos = nx.spring_layout(G, seed=42)
# Manually set the position of the center node to the origin (0, 0)
pos[center_node] = (0, 0)
# Calculate the offset (difference between the center and other node positions)
# Now, shift the other nodes relative to the center node's fixed position
x_offset = pos[center_node][0]
y_offset = pos[center_node][1]
# Adjust the positions of all nodes
for node in pos:
    if node != center_node:
        # Calculate the new relative position with respect to the center
        pos[node] = (pos[node][0] - x_offset, pos[node][1] - y_offset)
# Now the center node is at (0, 0) and the rest are adjusted accordingly


# Adjust the layout based on edge weights (stronger edges pull nodes closer)
for edge in G.edges():
    x0, y0 = pos[edge[0]]
    x1, y1 = pos[edge[1]]
    
    # Adjust the distance based on edge weight (higher weight -> closer nodes)
    edge_weight = adj_matrix[edge[0], edge[1]]*0.05
    
    # You can use a scaling factor to control how much the edge weight affects the distance
    scaling_factor = 0.001  # Experiment with this value to control the effect
    distance = edge_weight * scaling_factor
    
    # Update positions to pull nodes closer for stronger edges
    pos[edge[0]] = (x0 + distance, y0 + distance)
    pos[edge[1]] = (x1 - distance, y1 - distance)


# Extract node positions
nodes_x = [pos[node][0] for node in G.nodes()]
nodes_y = [pos[node][1] for node in G.nodes()]

# Calculate node size based on degree (connections)
#node_sizes = [G.degree(node) * 5 for node in G.nodes()]  # Degree-based size scaling

# not sure how to use this:
centrality = nx.betweenness_centrality(G)  # or closeness_centrality, degree_centrality, etc.
node_sizes = [centrality[node] * 100 for node in G.nodes()]

'''
# Detect communities (optional: community detection)
communities = girvan_newman(G)
first_community = next(communities)  # Get the first split (you can adjust this)
# Assign colors to communities
community_colors = {node: i for i, community in enumerate(first_community) for node in community}
node_colors = [community_colors[node] for node in G.nodes()]
'''

# Detect all communities (from all splits generated by Girvan-Newman)
communities = girvan_newman(G)
# Create an empty dictionary to store colors for all communities
community_colors = {}
# Iterate over all communities in the first split (WHAT ABOUT THE OTHER SPLITS)
for i, community_set in enumerate(next(communities)):  # Get the first split of communities
    for node in community_set:
        community_colors[node] = i  # Assign a color (community index)
# Assign colors to nodes based on community
node_colors = [community_colors[node] for node in G.nodes()]


# Assign node shapes based on community
community_shapes = {0: 'circle', 1: 'square', 2: 'diamond', 3: 'triangle', 4: 'star', 5: 'hexagon', 6: 'pentagon', 7: 'x', 8: 'bowtie'}  # Define shape for each community
node_shapes = [community_shapes[community_colors[node]] for node in G.nodes()]

# Prepare hover info (additional details when hovering over nodes)
hover_info = [f"Name: {name}<br>Connections: {G.degree(name)}" for name in people]

# Create the nodes scatter plot (representing people)
nodes = go.Scatter(
    x=nodes_x, y=nodes_y,
    mode='markers+text',
    name='People',
    text=people,  # Labels for each node (person)
    textposition='top center',
    hovertext=hover_info,  # Add more info on hover
    marker=dict(
        size=node_sizes,  # Vary size based on node degree
        color=node_colors,  # Color based on community
        colorscale='Viridis',  # Color scale for communities
        colorbar=dict(title="Organization", tickvals=[0, 1, 2], ticktext=["Community 1", "Community 2", "Community 3"]), # here for example
        symbol=node_shapes,
        line=dict(color='black', width=1)
    )
)

# Extract edges data for plotting
edges_x = []
edges_y = []

for edge in G.edges():
    x0, y0 = pos[edge[0]]
    x1, y1 = pos[edge[1]]
    edges_x.append(x0)
    edges_y.append(y0)
    edges_x.append(x1)
    edges_y.append(y1)

# Create the edges line plot (representing connections between people)
edges = go.Scatter(
    x=edges_x, y=edges_y,
    mode='lines',
    name='Connections',
    line=dict(width=1, color='gray')
)

# Combine nodes and edges into one Plotly figure
fig = go.Figure(data=[edges, nodes])

# Customize the layout of the graph
fig.update_layout(
    title="Human Network Graph",
    showlegend=True,
    legend_title="Communities",
    legend=dict(x=0.85, y=0.95),
    hovermode='closest',
    xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
    yaxis=dict(showgrid=False, zeroline=False, showticklabels=False)
)

# Show the interactive plot
fig.show()

# To add the plot to the existing AGILE webpage
# I want this html file to go straight to the 
# visual_graphs directory
#fig.write_html("interactive_network_graph.html")